---
alwaysApply: false
description: This is coding Standards for Melodia
---

# Coding Standards for Melodia

## TypeScript & React Standards

### File Organization
- Use PascalCase for component files: `MediaPlayer.tsx`, `SongList.tsx`
- Use camelCase for utility files: `utils.ts`, `actions.ts`
- Use kebab-case for page files: `song-details.tsx`

### Component Structure
Follow the pattern from [src/components/MediaPlayer.tsx](mdc:src/components/MediaPlayer.tsx):

```typescript
import { useState, useRef, useEffect, useCallback } from "react";
import { Button } from "@/components/ui/button";
// ... other imports

interface ComponentProps {
  // Define props interface
}

export const ComponentName = ({ prop1, prop2 }: ComponentProps) => {
  // State declarations
  const [state, setState] = useState();
  
  // Refs
  const ref = useRef();
  
  // Effects
  useEffect(() => {
    // Effect logic
  }, [dependencies]);
  
  // Event handlers
  const handleEvent = useCallback(() => {
    // Handler logic
  }, [dependencies]);
  
  return (
    // JSX
  );
};
```

### Type Definitions
Follow the pattern from [src/types/index.ts](mdc:src/types/index.ts):

```typescript
export interface InterfaceName {
  id: number
  created_at: string
  title: string
  // ... other fields
}
```

### Server Actions
Follow the pattern from [src/lib/actions.ts](mdc:src/lib/actions.ts):

```typescript
'use server'

import { Song, PublicSong } from '@/types';
import { createServerSupabaseClient } from './supabase';

export async function actionName(
  param1: string,
  param2: number,
  ip: string = 'unknown'
): Promise<{
  data: any
  error?: string
}> {
  try {
    // Input validation
    if (!validateInput(param1)) {
      return { data: null, error: 'Invalid input' }
    }
    
    // Rate limiting
    if (!checkRateLimit(ip)) {
      return { data: null, error: 'Too many requests' }
    }
    
    // Database operations
    const supabase = createServerSupabaseClient();
    // ... database logic
    
    return { data: result }
  } catch (error) {
    console.error('Error in actionName:', error);
    return { data: null, error: 'Internal server error' }
  }
}
```

### Custom Hooks
Follow the pattern from [src/hooks/use-song.ts](mdc:src/hooks/use-song.ts):

```typescript
import { useState, useEffect, useCallback } from 'react'
import { Song } from '@/types'

export const useCustomHook = (param: string) => {
  const [data, setData] = useState<Song[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  
  const fetchData = useCallback(async () => {
    try {
      setLoading(true)
      setError(null)
      // ... fetch logic
    } catch (err) {
      setError('Failed to fetch data')
    } finally {
      setLoading(false)
    }
  }, [param])
  
  useEffect(() => {
    fetchData()
  }, [fetchData])
  
  return {
    data,
    loading,
    error,
    refetch: fetchData
  }
}
```

### Import Organization
1. React imports
2. Next.js imports
3. Third-party library imports
4. Internal component imports
5. Internal utility imports
6. Type imports

### Error Handling
- Always use try-catch blocks in async functions
- Return structured error responses
- Log errors with context
- Provide user-friendly error messages

### Performance
- Use `useCallback` for event handlers
- Use `useMemo` for expensive calculations
- Implement proper loading states
- Use React.memo for expensive components

### Accessibility
- Add proper ARIA labels
- Use semantic HTML elements
- Ensure keyboard navigation
- Provide alt text for images