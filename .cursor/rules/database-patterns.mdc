---
alwaysApply: false
---
# Database Patterns for Melodia

## Database Architecture Principles

### Single Responsibility Principle
Separate database concerns into focused modules:

```typescript
// Database service interface (Dependency Inversion)
export interface DatabaseService {
  findById<T>(table: string, id: string): Promise<T | null>;
  findMany<T>(table: string, filters?: Record<string, any>): Promise<T[]>;
  create<T>(table: string, data: Partial<T>): Promise<T>;
  update<T>(table: string, id: string, data: Partial<T>): Promise<T>;
  delete(table: string, id: string): Promise<void>;
  executeQuery<T>(query: string, params?: any[]): Promise<T[]>;
}

// Repository pattern for specific entities
export interface SongRepository {
  findById(id: string): Promise<Song | null>;
  findByUserId(userId: string): Promise<Song[]>;
  create(songData: CreateSongData): Promise<Song>;
  update(id: string, songData: Partial<Song>): Promise<Song>;
  delete(id: string): Promise<void>;
  search(query: string): Promise<Song[]>;
}
```

### Repository Pattern Implementation
```typescript
// Base repository with common operations
export abstract class BaseRepository<T extends { id: string }> {
  constructor(
    protected db: DatabaseService,
    protected tableName: string
  ) {}

  async findById(id: string): Promise<T | null> {
    return this.db.findById<T>(this.tableName, id);
  }

  async findMany(filters?: Record<string, any>): Promise<T[]> {
    return this.db.findMany<T>(this.tableName, filters);
  }

  async create(data: Partial<T>): Promise<T> {
    return this.db.create<T>(this.tableName, data);
  }

  async update(id: string, data: Partial<T>): Promise<T> {
    return this.db.update<T>(this.tableName, id, data);
  }

  async delete(id: string): Promise<void> {
    return this.db.delete(this.tableName, id);
  }
}

// Specific repository implementation
export class SongRepositoryImpl extends BaseRepository<Song> implements SongRepository {
  constructor(db: DatabaseService) {
    super(db, 'songs');
  }

  async findByUserId(userId: string): Promise<Song[]> {
    return this.db.findMany<Song>('songs', { user_id: userId });
  }

  async search(query: string): Promise<Song[]> {
    const searchQuery = `
      SELECT * FROM songs 
      WHERE title ILIKE $1 OR artist ILIKE $1
      ORDER BY created_at DESC
    `;
    return this.db.executeQuery<Song>(searchQuery, [`%${query}%`]);
  }
}
```

## Supabase Integration Patterns

### Client-Side Database Operations
```typescript
// Supabase client wrapper with error handling
export class SupabaseService implements DatabaseService {
  constructor(private supabase: SupabaseClient) {}

  async findById<T>(table: string, id: string): Promise<T | null> {
    try {
      const { data, error } = await this.supabase
        .from(table)
        .select('*')
        .eq('id', id)
        .single();

      if (error) {
        console.error(`Error fetching ${table} by id:`, error);
        return null;
      }

      return data as T;
    } catch (error) {
      console.error(`Unexpected error fetching ${table} by id:`, error);
      return null;
    }
  }

  async findMany<T>(table: string, filters?: Record<string, any>): Promise<T[]> {
    try {
      let query = this.supabase.from(table).select('*');

      if (filters) {
        Object.entries(filters).forEach(([key, value]) => {
          query = query.eq(key, value);
        });
      }

      const { data, error } = await query;

      if (error) {
        console.error(`Error fetching ${table}:`, error);
        return [];
      }

      return data as T[];
    } catch (error) {
      console.error(`Unexpected error fetching ${table}:`, error);
      return [];
    }
  }

  async create<T>(table: string, data: Partial<T>): Promise<T> {
    try {
      const { data: result, error } = await this.supabase
        .from(table)
        .insert(data)
        .select()
        .single();

      if (error) {
        throw new Error(`Failed to create ${table}: ${error.message}`);
      }

      return result as T;
    } catch (error) {
      console.error(`Error creating ${table}:`, error);
      throw error;
    }
  }

  async update<T>(table: string, id: string, data: Partial<T>): Promise<T> {
    try {
      const { data: result, error } = await this.supabase
        .from(table)
        .update({ ...data, updated_at: new Date().toISOString() })
        .eq('id', id)
        .select()
        .single();

    if (error) {
        throw new Error(`Failed to update ${table}: ${error.message}`);
      }

      return result as T;
    } catch (error) {
      console.error(`Error updating ${table}:`, error);
      throw error;
    }
  }

  async delete(table: string, id: string): Promise<void> {
    try {
      const { error } = await this.supabase
        .from(table)
        .delete()
        .eq('id', id);

      if (error) {
        throw new Error(`Failed to delete ${table}: ${error.message}`);
      }
    } catch (error) {
      console.error(`Error deleting ${table}:`, error);
      throw error;
    }
  }

  async executeQuery<T>(query: string, params?: any[]): Promise<T[]> {
    try {
      const { data, error } = await this.supabase.rpc('execute_sql', {
        query,
        params: params || []
      });

      if (error) {
        console.error('Error executing query:', error);
        return [];
      }

      return data as T[];
  } catch (error) {
      console.error('Unexpected error executing query:', error);
      return [];
    }
  }
}
```

### Server-Side Database Operations
```typescript
// Server-side Supabase client with RLS
export const createServerSupabaseClient = () => {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );
};

// Server actions with database operations
'use server'

import { createServerSupabaseClient } from '@/lib/supabase';
import { revalidatePath } from 'next/cache';

export async function createSongAction(formData: FormData) {
  const supabase = createServerSupabaseClient();
  
  try {
    // Get authenticated user
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return { error: 'Authentication required' };
    }

    // Extract and validate form data
    const title = formData.get('title') as string;
    const artist = formData.get('artist') as string;

    if (!title?.trim() || !artist?.trim()) {
      return { error: 'Title and artist are required' };
    }

    // Create song with user association
    const { data, error } = await supabase
      .from('songs')
      .insert({
        title: title.trim(),
        artist: artist.trim(),
        user_id: user.id,
        created_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      console.error('Database error:', error);
      return { error: 'Failed to create song' };
    }

    // Revalidate relevant pages
    revalidatePath('/my-songs');
    revalidatePath('/');

    return { data };
  } catch (error) {
    console.error('Unexpected error:', error);
    return { error: 'An unexpected error occurred' };
  }
}
```

## Data Access Patterns

### Custom Hooks for Data Fetching
```typescript
// Generic data fetching hook
export const useDataFetching = <T>(
  fetchFn: () => Promise<T[]>,
  dependencies: any[] = []
) => {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const result = await fetchFn();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch data');
    } finally {
      setLoading(false);
    }
  }, dependencies);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
};

// Specific hooks for different entities
export const useSongs = (userId?: string) => {
  const songRepo = useMemo(() => new SongRepositoryImpl(supabaseService), []);
  
  return useDataFetching(
    () => userId ? songRepo.findByUserId(userId) : songRepo.findMany(),
    [userId]
  );
};

export const useSong = (id: string) => {
  const [song, setSong] = useState<Song | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchSong = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      const songRepo = new SongRepositoryImpl(supabaseService);
      const result = await songRepo.findById(id);
      setSong(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch song');
    } finally {
      setLoading(false);
    }
  }, [id]);

  useEffect(() => {
    if (id) {
      fetchSong();
    }
  }, [fetchSong, id]);

  return { song, loading, error, refetch: fetchSong };
};
```

### Optimistic Updates
```typescript
// Optimistic update pattern for better UX
export const useOptimisticUpdate = <T extends { id: string }>(
  updateFn: (id: string, data: Partial<T>) => Promise<T>,
  onSuccess?: (updatedItem: T) => void,
  onError?: (error: Error) => void
) => {
  const [isUpdating, setIsUpdating] = useState(false);

  const update = useCallback(async (id: string, data: Partial<T>) => {
    setIsUpdating(true);
    
    try {
      const result = await updateFn(id, data);
      onSuccess?.(result);
      return result;
    } catch (error) {
      onError?.(error as Error);
      throw error;
    } finally {
      setIsUpdating(false);
    }
  }, [updateFn, onSuccess, onError]);

  return { update, isUpdating };
};

// Usage example
export const useSongUpdate = () => {
  const { update, isUpdating } = useOptimisticUpdate(
    async (id: string, data: Partial<Song>) => {
      const songRepo = new SongRepositoryImpl(supabaseService);
      return songRepo.update(id, data);
    },
    (updatedSong) => {
      // Update local state optimistically
      console.log('Song updated:', updatedSong);
    },
    (error) => {
      // Handle error and potentially revert optimistic update
      console.error('Update failed:', error);
    }
  );

  return { updateSong: update, isUpdating };
};
```

## Database Schema Patterns

### Consistent Entity Structure
```typescript
// Base entity interface for all database entities
export interface BaseEntity {
  id: string;
  created_at: string;
  updated_at: string;
}

// Specific entity interfaces
export interface Song extends BaseEntity {
  title: string;
  artist: string;
  duration?: number;
  user_id: string;
  is_public: boolean;
  metadata?: Record<string, any>;
}

export interface User extends BaseEntity {
  email: string;
  name: string;
  avatar_url?: string;
  preferences?: Record<string, any>;
}
```

### Migration Patterns
```typescript
// Database migration utilities
export const createMigration = (name: string, up: string, down: string) => {
  return {
    name,
    up,
    down,
    timestamp: new Date().toISOString()
  };
};

// Example migration
export const addSongMetadataMigration = createMigration(
  'add_song_metadata',
  `
    ALTER TABLE songs 
    ADD COLUMN metadata JSONB DEFAULT '{}';
    
    CREATE INDEX idx_songs_metadata ON songs USING GIN (metadata);
  `,
  `
    DROP INDEX IF EXISTS idx_songs_metadata;
    ALTER TABLE songs DROP COLUMN IF EXISTS metadata;
  `
);
```

## Error Handling and Logging

### Database Error Handling
```typescript
// Centralized error handling for database operations
export class DatabaseError extends Error {
  constructor(
    message: string,
    public code?: string,
    public details?: any
  ) {
    super(message);
    this.name = 'DatabaseError';
  }
}

export const handleDatabaseError = (error: any): DatabaseError => {
  if (error.code === '23505') {
    return new DatabaseError('Duplicate entry', 'DUPLICATE', error.details);
  }
  
  if (error.code === '23503') {
    return new DatabaseError('Foreign key constraint violation', 'FOREIGN_KEY', error.details);
  }
  
  if (error.code === '23502') {
    return new DatabaseError('Required field missing', 'NOT_NULL', error.details);
  }
  
  return new DatabaseError('Database operation failed', 'UNKNOWN', error);
};

// Usage in database operations
export const safeDatabaseOperation = async <T>(
  operation: () => Promise<T>
): Promise<{ data?: T; error?: DatabaseError }> => {
  try {
    const data = await operation();
    return { data };
  } catch (error) {
    const dbError = handleDatabaseError(error);
    console.error('Database operation failed:', dbError);
    return { error: dbError };
  }
};
```

## Performance Optimization

### Query Optimization
```typescript
// Efficient query patterns
export const getSongsWithPagination = async (
  page: number = 1,
  limit: number = 20,
  filters?: Record<string, any>
) => {
  const offset = (page - 1) * limit;
  
  const query = supabase
    .from('songs')
    .select('*', { count: 'exact' })
    .range(offset, offset + limit - 1)
    .order('created_at', { ascending: false });

  if (filters) {
    Object.entries(filters).forEach(([key, value]) => {
      query.eq(key, value);
    });
  }

  const { data, error, count } = await query;

  return {
    data: data || [],
    total: count || 0,
    page,
    limit,
    hasMore: (count || 0) > offset + limit
  };
};

// Caching strategy
export const createCachedRepository = <T>(
  repository: Repository<T>,
  ttl: number = 300000 // 5 minutes
) => {
  const cache = new Map<string, { data: T; timestamp: number }>();

  return {
    ...repository,
    findById: async (id: string): Promise<T | null> => {
      const cached = cache.get(id);
      if (cached && Date.now() - cached.timestamp < ttl) {
        return cached.data;
      }

      const data = await repository.findById(id);
      if (data) {
        cache.set(id, { data, timestamp: Date.now() });
      }
      return data;
    }
  };
};
```